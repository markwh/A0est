
#' Estimate A0 
#' 
#' Fits model for A0 of one of several variants using Hamiltonian Monte Carlo.
#' 
#' @param bamdata A bamdata object, as produced by \code{bam_data()}
#' @param variant Which BAM variant to use: amhg, manning_amhg, or manning
#' @param meas_error Include measurement error in inference? Setting this to TRUE 
#'   will slow down the inference by roughly an order of mangnitude.
#' @param reparam Reparameterize measurement errors to speed up sampling?
#' @param bampriors A bampriors object. If none is supplied, defaults are used 
#'   from calling \code{bam_priors(bamdata)} (with no other arguments).
#' @param cores Number of processing cores for running chains in parallel. 
#'   See \code{?rstan::sampling}. Defaults to \code{parallel::detectCores}.
#' @param chains A positive integer specifying the number of Markov chains. 
#'   The default is 3.
#' @param iter Number of iterations per chain (including warmup). Defaults to 1000.
#' @param stanmodel A \code{stanmodel} object to use instead of one of the default 
#'   models. 
#' @param pars (passed to rstan::sampling) A vector of character strings specifying 
#'   parameters of interest. For bam_estimate, the default is Stan transformed  
#'   variables, "man_rhs", "amhg_rhs", and "logA_man".
#' @param include Defaults to FALSE, which omits parameters specified in 
#'   \code{pars}. If set to TRUE, only the \code{pars} parameters will be returned.
#' @param ... Other arguments passed to rstan::sampling() for customizing the 
#'   Monte Carlo sampler
#' @import rstan
#' @export

bam_estimate <- function(bamdata, 
                         variant = c("manning", "amhg", "manning_amhg"), 
                         bampriors = NULL, 
                         meas_error = TRUE,
                         reparam = TRUE,
                         cores = getOption("mc.cores", default = parallel::detectCores()),
                         chains = 3L,
                         iter = 1000L,
                         stanmodel = NULL,
                         ...) {
  variant <- match.arg(variant)
  stopifnot(is(bamdata, "bamdata"))
  if (is.null(bampriors))
    bampriors <- bam_priors(bamdata, variant = variant)
  stopifnot(is(bampriors, "bampriors"))
  
  baminputs <- compose_bam_inputs(bamdata, bampriors)
  
  if (!is.null(stanmodel)) {
    stopifnot(inherits(stanmodel, "stanmodel"))
    stanfit <- stanmodel
  } else {
    if (!meas_error | reparam) {
      variant <- paste0(variant, "_nolatent")
    }
    stanfit <- stanmodels[[variant]]
  }
  
  if (reparam) {
    logS_sigsq_obs <- ln_sigsq(obs = baminputs$Sobs, err_sigma = baminputs$Serr_sd)
    logW_sigsq_obs <- ln_sigsq(obs = baminputs$Wobs, err_sigma = baminputs$Werr_sd)
    baminputs$sigma_man <- sqrt(baminputs$sigma_man^2 + 
                                  logS_sigsq_obs * 9 +
                                  logW_sigsq_obs * 16)
    baminputs$sigma_amhg <- sqrt(baminputs$sigma_amhg^2 +
                                   logW_sigsq_obs)
  }
  
  out <- sampling(stanfit, data = baminputs, 
                  cores = cores, chains = chains, iter = iter,  
                  pars = c("man_rhs", "amhg_rhs", "logA_man", 
                           "Wact", "Sact", "dAact", "logW", "logS", 
                           "man_lhs"),
                  include = FALSE,
                  ...)
  
  out
}


bam_q_manning <- function(bamdata, params, plot = TRUE) {
  logn <- params$logn
  A0mat <- matrix(params$A0, nrow = bamdata$nx, ncol = bamdata$nt, byrow = FALSE)
  logA <- log(bamdata$dAobs + A0mat)
  logW <- log(bamdata$Wobs)
  logS <- log(bamdata$Sobs)
  logQ <- 5/3 * logA - logn - 2/3 * logW + 1/2 * logS
  q <- exp(logQ)
}


